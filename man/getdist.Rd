% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{getdist}
\alias{getdist}
\title{L1 Distance}
\usage{
getdist(target, observed, K, svd.U = NULL, w = NULL, numdims = NULL,
  w.pop = NULL, ebal.tol = NULL)
}
\arguments{
\item{target}{a numeric vector of length equal to the total number of units where population units take a value of 1 and sample units take a value of 0.}

\item{observed}{a numeric vector of length equal to the total number of units where sampled units take a value of 1 and population units take a value of 0.}

\item{K}{the kernel matrix}

\item{svd.U}{a matrix of left singular vectors from from performing \code{svd()} on the kernel matrix.}

\item{w}{a numeric vector of weights for every obervation. If unspecified, these are found using \code{numdims} dimensions of the SVD of the kernel matrix \code{svd.out$u} with custom entropy balancing function \code{ebalance_custom()}. Note that these weights should sum to the total number of units, where treated or population units have a weight of 1 and control or sample units have appropriate weights dervied from kernel balancing with mean 1 which is consistent with the ouput of \code{getw()}.}

\item{numdims}{a numeric input specifying the number of columns of the singular value decomposition of the kernel matrix to use when finding weights in the case that \code{w} is not specified.}

\item{w.pop}{an optional vector input to specify population weights. Must be of length equal to the total number of units/rows in \code{allx} with all sampled units recieving a weight of 1. The sum of the weights for population units must be either 1 or the number of population units.}

\item{ebal.tol}{an optional numeric input speccifying the tolerance level used by custom entropy balancing function \code{ebalance_custom()} in the case that \code{w} is not specified. When not specified, the default is 1e-6/}
}
\value{
\item{w}{numeric vector of weights used}
\item{L1}{a numeric giving the L1 distance, the absolute difference between \code{pX_D1} and \code{pX_D0w}}
\item{pX_D1}{a numeric vector of length equal to the total number of observations where the nth entry is the sum of the kernel distances from the nth unit to every treated or population unit.}
\item{pX_D0}{a numeric vector of length equal to the total number of observations where the nth entry is the sum of the kernel distances from the nth unit to every control or sampled unit.}
\item{pX_D0w}{a numeric vector of length equal to the total number of observations where the nth entry is the weighted sum of the kernel distances from the nth unit to every control or sampled unit. The weights are given by entropy balancing and produce mean balance on \eqn{\phi(X)}, the expaned features of \eqn{X} using a given kernel \eqn{\phi(.)}, for the control or sample group and treated group or target population.}
}
\description{
Calculates the L1 distance between the treated or population units and the kernel balanced control or sampled units.
}
\examples{
\donttest{
#loading and cleaning lalonde data
data(lalonde)
lalonde$nodegr=as.numeric(lalonde$educ<=11)
xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#need to first build gaussian kernel matrix
K_pass <- makeK(allx = lalonde[,xvars])
#also need the SVD of this matrix
svd.U_pass <- svd(K_pass)

#running without passing weights in directly, using numdims=33
l1_lalonde <- getdist(target = lalonde$nsw,
                      observed = 1-lalonde$nsw,
                      K = K_pass,
                      svd.out = svd.U_pass,
                      numdims = 33)

 #alternatively, we can get the weights ourselves and pass them in directly
 w_opt <- getw(target= lalonde$nsw,
               observed = 1-lalonde$nsw,
               ebal.tol=1e-6)$w
 l1_lalonde2 <- getdist(target = lalonde$nsw,
                  observed = 1-lalonde$nsw,
                  K = K_pass,
                  w = w_opt)}
}
